# 8.2 스프링의 목적
 자바의 근본적인 목적은 객체지향 프로그래밍을 통해 유연하고 확장성 좋은 애플리케이션을 빠르게 만드는 것이다.
 
## 8.2.1 엔터프라이즈 개발의 복잡함
+ 2000년대 초반 각종 각종 자바 컨퍼런스에서 자주 논의됐던 주제는 '왜 자바 엔터프라이즈 JavaEE 프로젝트는 실패하는가?'였다
  + 여러가지 원인이 있었지만, 그중 가장 대표적인게 '엔터프라이즈 시스템 개발이 너무 복잡해져서' 였다.

### 복잡함의 근본적인 이유

#### 첫 번째는 기술적인 제약조건과 요구사항이 늘어가기 때문이다.
엔터프라이즈 시스템이란 서버에서 동작하며 기업과 조직의 업무를 처리해주는 시스템을 말한다.

뛰어난 성능과 안정성이 요구되고 그런 점을 고려한 개발기술이 필요
순수한 비즈니스 로직을 구현하는 것 외에도 기술적으로 고려할 사항이 많다.
웹을 통한 사용자 인터페이스뿐만 아니라, 타 시스템과의 자동화동 연계와 웹 이외의 클라이언트와의 접속을 위한 리모팅 기술도 요구
기업의 시스템이 복잡함에 따라 다중 데이터베이스를 하나의 트랜잭션으로 묶어서 사용하는 분산 트랜잭션의 지원
보안에 관한 부분도 갈수록 중요

시스템 설계자와 개발자 개개인이 져야 할 기술적인 부담은 점점 더 커져갔다.

#### 두 번째는 엔터프라이즈 애플리케이션이 구현해야 할 핵심기능인 비즈니스 로직의 복잡함이 증가하기 때문이다.
 버그나  오류가 있어서가 아니라, 기능 요구사항과 업무 정책 등이 바뀌기 때문에 애플리케이션을 자주 수정해줘야 하는 시대가 된것
 
 시스템 개발과 유지보수, 추가 개발 등의 작업에 대한 부담은 커지고 그에 따른 개발의 난이도는 더욱 증가
 

### 복잡함을 가중시키는 원인
자바 엔터프라이즈 시스템 개발이 어려운 가장 큰 이유는 근본적인 비즈니스 로직과 엔터프라이즈 기술이라는 두 가지 복잡함이 한데
얽혀 있기 때문이다.

예를 들면 이런 경우다. 고객의 기존 거래내역을 분석하고 그 특성을 파악해서 그에 따른 적절한 추천상품을 
선정하는 로직을 담당하는 코드를 작성한다고 생각해보자.

+ 그 작업요청을 XML 문서를 통한 리모팅 서비스로 받는다
+ 그것을 파싱해서 고객 ID를 추출하기 위해 XML 파서 라이브러리를 사용
+ 고객의 최신정보를 얻기 위해 DB를 조회할 때 캐시를 먼저 점검
+ 캐시 API호출
+ 없으면 서버가 제공하는 DB 풀에서 커넥션을 가져와서 JDBC API를 이용해 다양한 타입의 필드로된 정보를 가져옴
+ 가져온 정보를 분석한 내용을 만일을 위해 로그로 남겨 놓도록 분산 파일 시스템을 이용하는 로그 라이브러리를 매번 호출
+ 현재 요청을 보낸 사용자의 정보를 보안 API를 통해 가져와 요청한 작업에 대한 권한이 있는지 파악
+ 권한이 없으면 그에 따른 예외를 발생
+ 최종적으로 추천상품으로 선정한 내역을 로컬 DB에 저장하고 메시지로도 전송
+ 하나의 트랜잭션 안에서 동작하도록 하기 위해 JTA를 이용

 고객에 대한 추천제품 선정이라는 비즈니스로직을 제대로 구현하는 일도 만만치 않은데 동시에 이런저런 다양한 기술적인 문제도
 함께 신경 써야 한다면 어떨까?
 각종 엔터프라이즈 기술 서비스를 적용하기 위한코드와 각종 기술적인 API의 호출코드를 비즈니스 로직에 대한 구현코드와 함께 
 덕지덕지 붙여서 만드는것은 매우 어렵다. 더 큰문제는 그렇게 기술과 비즈니스 로직의 복잡함에 영켜 있는 코드를 유지보수하는 일이다.

전통적인 자바 엔터프라이즈 개발 기법은 대부분 비즈니스 로직의 복잡한 구현 코드와 엔터프라이즈 서비스를 이용하는 기술적인
코드가 자꾸 혼재될 수밖에 없는 방식이었다. 
결국 개발자가 동시에 그 두가지를 모두 신경 써서 개발해야 하는 과도한 부담을 줬고, 그에 따라 전체적인 복잡함은 몇배로 증가되었다.

## 8.2.2 복잡함을 해결하려는 도전
### 제거될 수 없는 근본적인 복잡함
비즈니스 로직의 복잡함을 효과적으로 다루기 위한 방법과 기술적인 복잡함을 효과적으로 처리하는 데 적용되는 방법이 다르다.
가장 먼저 할 일은 성격이 다른 이 두 가지 복잡함을 분리해내는 일이다.

### 실패한 해결책:EJB
EJB를 통해 애플리케이션 로직을 담은 핵심 코드에서 일부 기술적인 코드가 제거된 건 사실이지만, 오히려 EJB라는 환경과
스펙에 종속되는 코드로 만들어져야 하는 더 큰 부담을 안게 됐다.

EJB의 특정 클래스를 상속하게 함으로써 더 이상 상속구조를 적용하지 못하게 만들거나, 다형성 적용을 근본적으로 제한한다거나 하는것들이다.
EJB는 결국 객체지향적인 특성은 잃어버린 밋밋한 서비스 스크립트성 코드로 변질돼갔다.

### 비침투적인 방식을 통한 효과적인 해결책:스프링
EJB의 처음 목표와 마찬가지로 기술적인 복잡함을 애플리케이션 핵심 로직의 복잡함에서 제거하는 데 목표를 뒀다.

EJB처럼 어떤 기술을 적용했을 때 그 기술과 관련된 코드나 규약 등이 코드에 등장하는 경우를 침투적인(invasive) 기술이라고 한다.

비침투적인(non-invasive) 기술은 기술의 적용 사실이 코드에 직접 반영되지 않는다는 특징이 있다.
어디간에는 기술의 적용에 따라 필요한 작업을 해줘야 하겠지만
애플리케이션 코드 여기저기에 불쑥 등장하거나, 코드의 설계와 구현 방식을 제한하지는 않는다는 게 비침투적인 기술의 특징이다.

 스프링이 성공할 수 있었던 비결은 바로 비침투적인 기술이라는 전략을 택했기 때문이다.
스프링을 이용하면 기술적인 복잡함과 비즈니스 로직을 다루는 코드를 깔끔하게 분리할 수 있다.

스프링을 통해 성격이 다른 복잡함들을 깔끔하게 분리해줬기 때문에 각각을 효과적으로 상대할 수 있는 기반이 마련됐다.

## 8.2.3 복잡함을 상대하는 스프링의 전략
 스프링의 기본적인 전략은 비즈니스 로직을 담은 애플리케이션 코드와 엔터프라이즈 기술을 처리하는 코드를 분리시키는 것이다.
 
### 기술적 복잡함을 상대하는 전략
#### 첫번째 문제: 기술에 대한 접근 방식이 일관성이 없고, 특정 환경에 종속적이다.
 일관성 없는 기술과 서버환경의 변화에 대한 스프링의 공략 방법은 바로 서비스 추상화다.
 
데이터 액세스 예외에 대한 추상화는 비즈니스 로직을 담은 서비스 레이어의 코드가 특정 기술이 발생시키는 예외에 종속되지 않고,
불필요하게 예외를 잡아야 하거나 throws를 선언해야 하는 것을 방지해준다.

스프링이 제공하는 템플릿/콜백 패턴은 판에 박힌 반복적인 작업 흐름과 API 사용 코드를 제거해준다.

#### 두 번째 문제: 기술적인 처리를 담당하는 코드가 성격이 다른 코드에 섞여서 등장한다.
AOP는 최후까지 애플리케이션 로직을 담당하는 코드에 남아 있는 기술 관련 코드를 깔끔하게 분리해서 별도의 모듈로 관리하게 해주는 강력한 기술이다.

AOP는 기술을 다루는 코드로 인한 복잡함이 기술 그 자체 이상으로 불필요하게 증대되지 않도록 도와주는 가장 강력한 수단이다.

### 비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략
엔터프라이즈 시스템의 규모가 커지고, 복잡함이 증가하면서 DB에 비즈니스 로직을 두는 건 매우 불편할뿐더러 위험한 일이라고 여겨지기 시작했다.
가장확장하기 힘들고 확장하더라도 많은 비용이 드는 공유 자원인 DB에 커다란 부담을 주는 것도 문제고, 데이터 액세스를 중심으로 로직을 
다루면 개발과 유지보수는 물론이고 테스트도 매우 어렵다.

DB는 단지 데이터의 영구적인 저장과 복잡한 조건을 가진 검색과 같은 자체적으로 특화된 기능에만 활용하고,
데이터를 분석하고 가공하고 그에 따라 로직을 처리하는 부분은 확장하기 쉽고, 비용도 싼 애플리케이션 서버 쪽으로 이동하는 것이다.

객체지향 프로그래밍 기법과 언어가 주는 장점인 유연한 설계가 가능하고 재사용성이 높다는 점을 잘 활용하면 자주 바뀌고
조건이 까다로운 비즈니스 로직을 효과적으로 구현해낼 수 있다.

비즈니스 로직의 복잡함을 상대하는 전략은 자바라는 객체지향 기술 그 자체다.
스프링은 단지 객체지향 언어의 장점을 제대로 살리지 못하게 방해했던 요소를 제거하도록 도와줄 뿐이다.

### 핵심 도구: 객체지향과 DI
스프링의 모토는 결국 "기본으로 돌아가자"이다.
자바의 기본인 객체지향에 충실한 설계가 가능하도록 단순한 오브젝트로 개발할 수 있고, 객체지향의 설계 기법을 잘 적용할 수 있는
구조를 만들기 위해 DI 같은 유용한 기술을 편하게 적용하도록 도와주는것이 스프링의 기본전략이다.

기술적인 복잡함을 효과적으로 다루게 해주는 기법은 모두 DI를 바탕으로 하고 있다.
서비스 추상화, 템플릿/콜백, AOP와 같은 스프링의 기술은 DI없이는 존재할 수 없는 것들이다.

DI는 객체지향 설계 기술이 없이는 그 존재의 의미가 없다.
DI란 특별한 기술이라기보다는 유연하게 확장할수 있는 오브젝트 설계를 하다 보면 자연스럽게 적용하게 되는 객체지향 프로그래밍 기법일 뿐이다.
스프링은 단지 그것을 더욱 편하고 쉽게 사용하도록 도와줄 뿐이다.

DI는 자연스럽게 객체지향적인 설계와 개발로 이끌어주는 좋은 동반자다. DI가 자연스럽게 확장성이 좋은설계로 이끄는 과정을 생각해보자.
DI를 의식하다 보면 오브젝트를 설계할때 자주 DI를 적용할 후보가 더이상 없을까를 생각해보게 된다.
+ 여기서 바뀔 수 있는 것은 무엇일까?
+ 여기서 성격이 다르고,
+ 변경의 이유가 다른 기능은 무엇일까?

그리고 그런 후보를 찾을 수 있다면 DI를 적용해서 오브젝트를 분리하고, 인터페이스를 도입하고, DI로 관계를 연결해줄것이다.
결국 DI는 좋은 오브젝트 설계의 결과물이기도 하지만, 
반대로 DI를 열심히 적용하다 보면 객체지향 설계의 원칙을 잘 따르고 그 장점을 살린 설계가 나올 수도 있다.

기계적인 방법으로 항상 사용하는 틀에 박힌 구조의 빈만 정의하고 나머지 코드에는 DI를 적용해볼 생각조차 안 한다면 DI를 잘못 사용하고 있는것이다.

객체지향적인 특성을 잘 살린 설계는 상속과 다형성, 위임을 포함해서 많은 객체지향 디자인 패턴과 설계 기법이 잘 녹아들어 갈 수 있다.
기술적인 코드에 침범당하지 않았다면 이런 설계를 비즈니스 로직을 구현하는 코드에 그대로 반영할 수 있다.
