# 7.6 스프링 3.1의 DI
스프링을 이용해서 만들어지는 애플리케이션 코드가 DI 패턴을 이용해서 안전하게 발전하고 확장할 수 있는 것처럼 
스프링 프레임워크 자체도 DI원칙을 충실하게 따라서 만들어졌기 때문에 기존 설계와 코드에 영향을 주지 않고도 꾸준히
새로운 기능을 추가하고 확장해나가는 일이 가능했다.

### 자바 언어의 변화와 스프링

#### 애노테이션의 메타정보 활용
자바코드의 메타 정보를 이용한 프로그래밍
자바는 소스코드가 컴파일된후 클래스 파일에 저장됐다가, JVM에 의해 메모리로 로딩되어 실행된다.
그런데 때로는 자바코드가 실행되는 것이 목적이 아니라 다른 자바 코드에 의해 데이터처럼 취급되기도 한다.
자바 코드의 일부를 리플렉션 API 등을 이용해 어떻게 만들었는지 살펴보고 그에 따라 동작하는 기능이 점점 많이 사용되고 있다.

**애노테이션**은 옵션에 따라 컴파일된 클래스에 존재하거나 애플리케이션이 동작할때 메모리에 로딩되기도 하지만 자바 코드가
실행되는데 직접 참여하지 못한다.
인터페이스처럼 오브젝트에 타입을 부여하는 것도 아니고, 그 자체로 상속이나 오버라이딩이 가능하지도 않다.
동작하는 코드를 넣을 수 없는 것은 물로이고, 코드에서 간단히 참조하거나 활용할 수가 없다.
복잡한 리플렉션 API를 이용해 애노테이션의 메타정보를 조회하고, 애노테이션 내에 설정된 값을 가져와 참고하는 방법이 전부다.

애노테이션의 활용이 늘어난 이유는 무엇일까?
애노테이션은 애플리케이션을 핵심 로직을 담은 자바 코드와 이를 지원하는 IoC 방식의 프레임워크,
그리고 프레임워크가 참조하는 메타정보라는 세가지로 구성하는 방식에 잘 어울리기 때문일 것이다.
애노테이션은 프레임워크가 참조하는 메타정보로 사용되기에 여러 가지 유리한 점이 많다. 

DI의 기본원리를 소개했던 1장의 내용을 다시 생각해보자 
핵심코드가 런타임 시 동적으로 관계를 맺고 동작하도록 만들어주는 DaoFatory, 그리고 DaoFactory를 활용해 핵심 로직 코드가 서로 관계를 맺고
동작하는 모든 과정을 제어하는 클라이언트 코드, 
핵심 로직을 담은 오브젝트가 클라이언트에 의해 생성되고, 관계를 맺고 제어되는 구조다. 따라서 이때의 클라이언트는 일종의 IoC 프레임워크로 볼수 있다.
또한 DaoFactory는 IoC 프레임워크가 참고하는 일종의 메타정보로 의미가 있다.

런타임 의존관계 정보를 담고 있는 DaoFactory는 처음엔 평범한 자바코드로 작성됐다.
UserDao 한가지가 아니라 애플리케이션을 구성하는 많은 오브젝트의 관계를 IoC/DI를 이용해서 프레임워크와 
메타정보를 활용하는 방식으로 작성하도록 발전시키려면 DaoFactory와 같은 단순한 자바 코드로 만들어진 관계 설정 책임을 담은 코드는 불편하다.
그래서 1.8절에서는 DaoFactory의 내용을 XML로 전환해서 좀 더 간결한 형태로 전환했다.
어차피 DaoFactory는 애플리케이션의 로직을 담은 코드에서 사용될 일이 없기때문에 형태가 어떻든지 상관없다.
XML이라면 DaoFactory 같은 자바 코드를 이용할 때보다 프레임워크가 할 일이 좀 더 많아지긴 하지만, 작성하기 편하고 빌드 과정이 필요 없으며,
AOP를 위해 빈생성과 관계 설정을 재구성하는 경우를 고려하면 자바코드보다 유리했기 때문에 스프링 초창기부터 XML이 프레임워크가 사용하는
오브젝트 관계 설정요 DI 메타정보로 적극 활용돼 왔다.


**애노테이션**은 XML이나 여타 외부파일과 달리 자바코드의 일부로 사용된다. 코드의 동작에 직접 영향을 주지는 못하지만
**메타정보**로서 활용되는 데는 XML 비해 유리한점이 많다.
다음과 같이 간단한 애노테이션이 사용된 코드를 살펴보자

```java
@Special
public class MyClass {
  ...
}
```
@Special 애노테이션이 타입 레벨, 즉 클래스에 부여했다는 사실을 알수 있다.
애노테이션은 정의하기에 따라서 타입, 필드, 메소드, 파라미터, 생성자, 로컬변수의 한군데 이상 적용 가능하다.
위의 코드에선 클래스 레벨에 적용한다는 정보를 얻을수 있다.
애노테이션이 위치한 MyClass 클래스이 메타정보를 얻을수 있다.
애노테이션이 부여된 클래스의 패키지, 클래스 이름, 접근 제한자 상속한 클래스나 구현 인터페이스가 무엇인지 알수 있다.
원한다면 클래스의 필드나 메소드 구성도 확인할수 있다.

단순한 애노테이션 하나를 자바코드에 넣는 것만으로도, 애노테이션을 참고하는 코드에서는 이렇게  다양한 부가정보를 얻어 낼수 있다.

반면에 동일한 정보를 XML로 표현하려면 모든 내용을 명시적으로 나타내야 한다. 
간단히 클래스가 무엇인지만 지정하려고 해도 다음과 같이 작성해야 한다.
```xml
<x:special target="type" class="com.mycompany.myproject.MyClass" />
```

객체지향 언어의 기본에 충실하게 작성된 자바 코드 형태로 시작됐던 DI 패턴은 프레임워크의 발전과 함께
자바코드와 프레임워크, XML 메타정보의 형태로 진행되다가 스프링 3.1 이르러서는 핵심 로직을 담은 자바 코드와 DI 프레임워크,
그리고 DI를 위한 메타데이터로서의 자바 코드로 재구성되고 있다.

#### 정책과 관례를 이용한 프로그래밍
애노테이션 같은 메타정보를 활요하는 프로그래밍 방식은 코드를 이용해 명시적으로 동작 내용을 기술하는 대신 코드 없이도 미리 약속한
규칙 또는 관례를 따라서 프로그램이 동작하도록 만드는 프로그래밍 스타일을 적극적으로 포용하게 만들어왔다.
DaoFactory 같은 자바 코드를 대체한 스프링의 XML도 미리 정의한 정책을 이용해서 특정 기능이 동작하게 만든것이라고 볼수 있다.
<bean> 태그를 작성해두면 그에 따라 하나의 오브젝트가 만들어진다. new 키워드를 이용한 인스턴스 생성 코드가 동작하는 세임이다.
미리 정의된 규칙을 따라서 프레임워크가 작업을 수행한다.
이런 스타일의 프로그래밍 방식은 자바 코드로 모든 작업 과정을 직접 표현했을 때에 비해서 작성해야 할 내용이 줄어든다는 장점이 있다.
좀 더 지능적으로, 자주 반복되는 부분을 관례화 하면 더 많은 내뇽을 생략할 수도 있다.

@Transactional을 제대로 활용하려면 관례화된 이 정책을 기억하고 코드를 작성해야 한다.
애노테이션을 메타정보 이용하면서도 명시적으로 정보를 넣도로 하지 않았다. 
그덕분에 코드는 간결해진다. 하지만 정책을 기억 못하거나 잘못 알고 있을 경우 의도한 대로 동작하지 않는 코드가 만들어질 수 있다.
트랜잭션 속성의 문제 같은 경우는 디버깅도 매우 어렵다.

스프링 3.1은 스프링 하면 제일 먼저 떠오르는 것 중의 하나였던 XML을 전혀 사용하지 않고도 스프링 애플리케이션을 만들 수 있다

스프링이 DI의 원리와 다양한 패턴을 빈과 DI 설정정보를 담은 자바 코드와 애노테이션 등에 어떻게 적용했는지도 눈여겨 보자.
리팩토링을 진행할 때 중요한 것은 테스트를 준비하는 일이다.
