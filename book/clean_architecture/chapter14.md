# 14장 컴포넌튼 결합

## ADP: 의존성 비순환 원칙
> 컴포넌트 의존성 그래프에 순환이 있어서는 안된다.

당신이 의존하고 있던 파일을 누군가 수정하면 당신 코드는 작동하지 않을수 있다.
개발팀 모두가 누군가가 마지막으로 수정한 코드 때문에 망가진 부분이 동작하도록 만들기 위해 코드를 
수정하고 또 수정하는 작업이 계속될 수 있다.
 
이 문제의 해결책
+ 주단위 빌드
+ 의존성 비순환 원칙 Acyclic Dependencies Principle, ADP

### 순환 의존성 제거하기
이 문제의 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다.
이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다.

어떤 팀도 다른 팀에 의해 좌우되지 않는다.
특정 컴포넌트가 변경되더라도 다른 팀에 즉각 영향을 주지는 않는다.
각 팀은 특정 컴포넌트가 새롭게 릴리스되면 자신의 컴포넌트를 해당 컴포넌트에 맞게 수정할 시기를 스스로 결정할 수 있다.
뿐만 아니라 통합은 작고 점진적으로 이뤄진다.
특정시점에 모든 개발자가 한데 모여서 진행중인 작업을 모두 통합하는 일은 사라진다.

이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야 한다.
의존성 구조에 순환이 있어서는 안된다.


### 순환이 컴포넌 의존성 그래프에 미치는 영향
순환이 생기면 컴포넌트를 분리하기가 상당히 어려워진다.
단위 테스트를 하고 릴리스를 하는 일도 굉장히 어려워지며 에러도 쉽게 발생한다.

의존성 그래프에 순환이 생기면 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기가 상당히 힘들어진다.
사실 순환이 생기면 올바른 순서라는것 자체가 없을수 있다.

### 순환 끊기
컴포넌트 사이의 순환을 끊고 의존성을 다시 DAG로 원상복구하는 일은 언제라도 가능하다.
이를 위한 주요 매커니즘 두가지
+ 의존성 역전 원칙 DIP를 적용한다.
+ 모두 의존하는 새로운 컴포넌트를 만든다.  그리고 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.

### 흐트러짐(Jitters)
두 번째 해결책에서 시사하는 바는 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다는 사실이다.

## 하향식 (top-down)설계
컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 일과는 거의 관련이 없다.
오히려 컴포넌트 의존성 다이어그램은 애플리케이션 빌드가능성과 유지보수성을 보여주는 지도와 같다.

바로 이러한 이유때문에 컴포넌트 구조는 프로젝트 초기에 설게할 수없다.
빌드하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한 지도 또한 필요 없기 때문이다.

변경되는 범위가 시스템의 가능한 한 작은 일부로 한정되기를 원한다.
그래서 결국 단일 책임 원칙과 공통 폐쇄 원칙에 관심을 갖기 시작하고, 이를 적용해 함께 변경되는 클래스는 같은 위치에 배치되도록 만든다.

컴포넌트 의존성 그래프는 자주 변경되는 컴포넌트로 부터 안정적이며 가치가 높은 컴포넌트를 보호하려는 아키텍트가 만들고 가다듬게 된다.

## SDP: 안정된 의존성 원칙
> 안정성의 방향으로(더 안정된 쪽에) 의존하라.

변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안된다. 
한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워진다.

안정된 의존성 원칙 (Stable Dependencies Principle, SDP)을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 
만들어진 모듈에 의존하지 않도록 만들 수 있다.

### 안정성
안정성은 변경을 만들기 위해 필요한 작업량과 관련된다.
옆면으로 선 동전이 안정적이지 않은 이유는 그다지 힘을 쓰지 않고도 넘어뜨릴수 있기 때문이다.
반면 탁자는 상당히 안정적인데, 탁자를 뒤집으려면 상당한 수고를 감수해야 하기 때문이다.

소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다.
컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이라고 볼 수 있는데, 사소한 변경이라도 의존하는
모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 들기 때문이다.

### 모든 컴포넌트가 안정적이어야 하는 것은 아니다
모든 컴포넌트가 최고로 안정적인 시스템이라면 변경이 불가능하다. 

#### 추상 컴포넌트
추상 컴포넌트는 상당히 안정적이며, 따라서 덜 안정적인 컴포넌트가 의존할수 있는 이상적인 대상이다.


## SAP: 안정된 추상화 원칙
> 컴포넌트는 안정된 정도만큼만 추상화 되어야 한다.

### 고수준 정책을 어디에 위치시켜야 하는가?
업무로직이나 아키텍처와 관련된 결정에는 변동서이 없기를 기대한다.
따라서 시스템에서 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트(I=0)에 위치해야 한다.

컴포넌트가 최고로 안정된 상태이면서도(I=0) 동시에 변경에 충분히 대응할수 있을 정도로 유연하게 만들수 있을까?
해답은 개방페쇄 원칙OCP에서 찾을수 있다.

OCP에서는 클래스를 수정하지 않고도 확장이 충분히 가능할 정도로 클래스를 유연하게 만들 수 있을 뿐만 아니라 
바람직한 방식이라고 말한다. 어떤 클래스가 이 원칙을 준수하는가? 바로 추상 abstract 클래스다.

### 안정된 추상화 원칙
안정된 추상화 원칙은 안정성과 추상화 정도 사이의 관계를 정의한다.
이 원칙은 한편으로는 안정된 컴포넌트는 추상 컴포넌트여야 하며, 
이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다고 말한다.
다른 한편으로는 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다고 말하는데, 컴포넌트가 불안정하므로
컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하기 때문이다.

## 결론
의존성 관리 지표는 설계의 의존성과 추상화 정도가 내가 '훌륭한' 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정한다.
