# 6장 함수형 프로그래밍
함수형 프로그래밍이라는 개념은 프로그래밍 그 자체보다 앞서 등장했다.
이 패러다임에서 핵심이 되는 기반은 람다 계산법으로 알로조 처치가 1930년대에 발명했다.

## 정수를 제곱하기
25까지의 정수의 제곱을 출력하는 간단한 문제를 다뤄보자

자바
```java
public class Squint {
  public static void main(String args[]) {
    for(int i=0; i<25; i++)
      System.out.println(i*i);
  }
}
```

클로저(Clojure)
```clojure
(println (take 25 (map (fn [x] (* x x)) (range))))
```

위의 코드 주석과 함께
```clojure
(println  ;___ 출력한다. 
  (take 25 ;___ 처음부터 25까지
    (map (fn [x] (* x x)) ;__ 제곱을 
      (range)))) ;___ 정수의
```

자바 프로그램은 가변 변수(mutable variable)를 사용하는데, 가변 변수는 프로그램 실행 중에 상태가 변할 수 있다.
앞의 예제에서 반복문을 제어하는 변수인 i가 가변 변수다.
클로저 프로그램에서는 이러한 가변 변수가 전혀 없다.
클로저에서는 x와 같은 변수가 한 번 초기화되면 절대로 변하지 않는다.

이는 우리에게 놀라운 사실을 알려준다. 함수형 언어에서는 변수는 변경되지 않는다.

## 불변성과 아키텍처
아키텍트는 왜 변수의 가변성을 염려하는가?
경합(race) 조건, 교착상태(deadlock) 조건, 동시 업데이트(concurrent update) 문제가 모두 가변 변수로 인해 발생하기 때문이다.

불변성이 정말로 실형가능한지?
저장 공간이 무한하고 프로세서의 속도가 무한히 빠르다고 전제한다면 가능.
자원이 무한대가 아니라면 대답은 조금 미묘하다.
불변성은 실현 가능하겠지만 일종의 타협을 해야 한다.

## 가변성의 분리
불변성과 관련하여 가장 주요한 타협 중 하나는 애플리케이션, 또는 애플리케이션 내부의 서비스를 
가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.

## 이벤트 소싱
더 많은 메모리를 확보할수록, 기계가 더 빨라질수록, 필요한 가변 상태는 더 적어진다.

이벤트 소싱(event sourcing)은 상태가 아닌 트랜잭션을 저장을 저장하자는 전략이다.
상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.

데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없다는 사실이다. 
결과적으로 애플리케이션은 CRUD가 아니라 그저 CR만 수행한다.
또한 데이터 저상소에서 변경과 삭제가 전혀 발생하지 않으므로 동시 업데이트 문제 또한 일어나지 않는다.

## 결론
함수형 프로그래밍은 변수 할당에 부과되는 규율이다.

1946년 앨런 튜링이 전자식 컴퓨터에서 실행할 거의 최초의 코드를 작성할 때 사용한 소프트웨어 규칙과
지금의 소프트웨어 규칙은 조금도 다르지 않다.
도구는 달라졌고 하드웨어도 변했지만, 소프트웨어의 핵심은 여전히 그대로다.

소프트웨어, 즉 컴퓨터 프로그램은 순차(sequence), 분기(selection), 반복(iteration), 참조(indirection)로 구성된다.
그 이상도 이하도 아니다.
