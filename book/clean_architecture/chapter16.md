# 16장 독립성

## 유스케이스
시스템의 아키텍처는 시스템의 의도를 지원해야 한다

## 운영
만약 시스템이 단일체(monolith)로 작성되어 모노리틱 구조를 갖는다면, 다중 프로세스, 다중 스레드, 또는 마이크로서비스 형태가
필요해질 때 개선하기가 어렵다. 그에 비해 아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로
제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다.

## 개발
콘웨이(Conway)의 법칙이 작용하는 지점
> 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.

## 배포
목표는 '즉각적인 배포(immediate deployment)'

이러한 아키텍처를 만들려면 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다.

## 선택사항 열어놓기
좋은 아키텍처는 컴포넌트 구조와 관련된 이 관심사들 사이에서 균형을 맞추고, 각 관심사 모두를 만족시킨다.

좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.

## 계층 결합 분리
아키텍트는 단일책임 원칙과 공통폐쇄 원칙을 적용하여, 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들은 묶는다.

서로 다른 이유로 변경되는 것은 무엇일까? 몇 가지 분명한 것이 있다.
사용자 인터페이스가 변경되는 이유는 업무 규칙과는 아무런 관련이 없다.

시스템을 서로 결합되지 않은 수평적인 계층으로 분리
- 이러한 계층의 예로는 UI, 애플리케이션에 특화된 업무규틱, 애플리케이션과는 독립적인 업무규칙, 데이터베이스 등을 들수 있다.

## 유스케이스 결합 분리
서로 다른 이유로 변경되는 것에는 바로 유스케이스 자체가 있다.
주문 입력 시스템에서 주문을 추가하는 유스케이스는 주문을 삭제하는 유스케이스와는 틀림없이 다른 속도로, 그리고 다른 이유로 변경된다.
유스케이스는 시스템을 분할하는 매우 자연스러운 방법이다.

이와 동시에 유스케이스는 시스템의 수평적인 계층을 가로지르도록 자른, 수직으로 좁다란 조각이기도 하다.

우리는 시스템을 수평적 계층으로 분할하면서 동시에 해당 계층을 가로지르는, 얇은 수직적인 유스케이스로 시스템을 분할할 수 있다.

시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할수 있게 된다.
또한 유스케이스를 뒷받침하는 UI와 데이터베이스를 서로 묶어서 각 유스케이스가 UI와 데이터베이스의 서로 다른 관점(aspect)을 사용하게 되면,
새로운 유스케이스를 추가하더라도 기존 유스케이스에 영향을 주는 일은 거의 없을 것이다.

## 결합 분리 모드
우리는 때때로 컴포넌트를 서비스 수준까지도 분리해야 한다

## 개발 독립성
컴포넌트가 완전히 분리되면 팀 사이의 간섭은 줄어든다.

## 배포 독립성
유스케이스와 계층의 결합이 분리되면 배포 측면에서도 고도의 유연성이 생긴다.

실제로 결합을 제대로 분리했다면 운영중인 시스템에서도 계층과 유스케이스를 교체(hot-swap)할수있다.

## 중복
아키텍트는 종종 함정에 빠지곤 한다.
전적으로 중복에 대한 공포로부터 발생하는 함정이다.

중복에도 여러종류가 있다. 
그중하나는 거짓된 또는 우발적인 중복이다.
중복으로 보이는 두코드 영역이 각자의 경로로 발전한다면, 즉 서로 다른 속도와 다른이유로 변경된다면 이 두 코드는 진짜 중복이 아니다.
몇년이 지나 다시 보면 두 코드가 매우 다르다는 사실을 알게 될 것이다.

해당 코드를 통합하지 않도록 유의해야 한다. 그렇지 않으면 나중에 코드를 다시 분리하느라 큰 수고를 감수해야 한다.

## 결합 분리 모드(다시)
계층과 유스케이스의 결합을 분리하는 방법

+ 소스 수준 분리 모드 : 소스 코드 모듈 사이의 의존성을 제어할수 있다.
+ 배포 수준 분리 모드 : jar 파일, DLL, 공유 라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어할 수 있다.
+ 서비스 수준 분리 모드 : 의존하는 수준을 데이터 구조 단위까지 낮출 수 있고, 순전히 네트워크 패킷을 통해서만 통신하도록 만들수 있다.

좋은 아키텍처는 시스템이 모노리틱 구조로 태어나서 단일 파일로 배포되더라도, 이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장하고,
또 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 한다.
또한 좋은 아키텍처라면 나중에 상황이 바뀌었을 때 이 진행 방향을 거꾸로 돌려 원래 형태인 모노리틱 구조로 되돌릴 수도 있어야 한다.

## 결론
시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며, 뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리 없이 반영할 수 있도록 만들어야 한다는 점이다.

