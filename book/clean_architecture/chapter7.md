# 3 설계원칙
좋은 소프트웨어 시스템은 깔끔한 코드(clean code)로부터 시작한다.
좋은 벽돌을 사용하지 않으면 빌딩의 아키텍처가 좋고 나쁨은 그리 큰 의미가 없는것과 같다.
반대로 좋은 벽돌을 사용하더라도 빌딩의 아키텍처를 엉망으로 만들수 있다.
그래서 좋은 벽돌로 좋은 아키텍처를 정의하는 원칙이 필요한데, 그게바로 SOLID다.

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다.
여기에서 클래스는 단순히 함수와 데이터를 결합하는 집합을 가리킨다.

SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는 데 있다.
+ 변경에 유연하다.
+ 이해하기 쉽다.
+ 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

'중간 수준'이라 함은 프로그래머가 이들 원칙을 모듈 수준에서 작업할때 적용할 수 있다는 뜻이다.

소프트웨어 설계 원칙들을 모아 첫번째 글자들로 SOLID라는 단어를 만들었다.
+ SRP : 단일 책임 원칙 Single Responsibility Principle
+ OCP : 개방-폐쇄 원칙 Open-Closed Principle
+ LSP : 리스코프 치환 원칙 Liskov Substitution Principle
+ ISP : 인터페이스 분리 원칙 Interface Segregation Principle
+ DIP : 의존성 역전 원칙 Dependency Inversion Principle

# 7장 SRP : 단일 책임 원칙
`단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.`

`하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야 한다.`

여기에서 사용자 또는 이혜관계자는 해당 변경을 요청하는 한 명이상의 사람들을 가리킨다.
이러한 집단을 액터(actor)라고 부르겠다.

이제 SRP의 최종 번전은 아래와 같다.

`하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.`

모듈은 단순히 함수와 데이터 구조로 구성된 응집된 집합이다.
'응집된(cohesive)'이라는 단어가 SRP를 암시한다. 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성이다.

이 원칙을 위반하는 징후들
## 징후 1: 우발적 중복
SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.

## 징후 2: 병합
소스 파일에 다양하고 많은 메소드를 포함하면 병합이 자주 발생하리라고 짐작하기는 어려운 일이 아니다.
특히 이들 메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성은 확실히 더 높다.

많은 사람이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우에 해당

## 해결책
데이터와 메서드를 분리하는 방식
'우연한 중복'을 피할 수 있다.

이 해결책은 개발자가 클래스를 인스턴스화하고 추적해야 한다는게 단점이다.
이러한 난관에서 빠져나올 때 흔히 쓰는 기법으로 퍼서드(Facade)패턴이 있다.

이 클래스는 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다. 

## 결론
단일 책임 원칙은 메서드와 클래스 수준의 원칙이다. 
하지만 이보다 상위의 두 수준에서도 다른 형태로 다시 등장한다. 
컴포넌트 수준에서는 공통 폐쇄 원칙(Common Clousure Principle)이 된다.
아키텍처 수준에서는 아키텍처 경계(Architectural Boundary)의 생성을 책임지는 변경의 축(Axis of Change)이 된다.

